/**
 * summary and tree commands
 *
 * - summary: Get project summary with auto-detected info
 * - tree: Get indexed file tree with optional stats
 */

import { existsSync, readFileSync, writeFileSync } from 'fs';
import { join, dirname, basename } from 'path';
import { PRODUCT_NAME, INDEX_DIR, TOOL_PREFIX } from '../constants.js';

import { openDatabase, createQueries } from '../db/index.js';

// ============================================================
// Types - Summary
// ============================================================

export interface SummaryParams {
    path: string;           // Project path
}

export interface SummaryResult {
    success: boolean;
    name: string;
    content: string;        // Markdown content of summary.md (if exists)
    autoGenerated: {
        entryPoints: string[];
        mainTypes: string[];
        fileCount: number;
        languages: string[];
    };
    error?: string;
}

// ============================================================
// Types - Tree
// ============================================================

export interface TreeParams {
    path: string;           // Project path
    subpath?: string;       // Subdirectory to list (default: root)
    depth?: number;         // Max depth (default: unlimited)
    includeStats?: boolean; // Include item/method counts per file
}

export interface TreeEntry {
    path: string;
    type: 'file' | 'directory';
    itemCount?: number;
    methodCount?: number;
    typeCount?: number;
}

export interface TreeResult {
    success: boolean;
    root: string;
    entries: TreeEntry[];
    totalFiles: number;
    error?: string;
}

// ============================================================
// Summary implementation
// ============================================================

export function summary(params: SummaryParams): SummaryResult {
    const { path: projectPath } = params;

    // Validate project path
    const indexDir = join(projectPath, INDEX_DIR);
    const dbPath = join(indexDir, 'index.db');

    if (!existsSync(dbPath)) {
        return {
            success: false,
            name: '',
            content: '',
            autoGenerated: {
                entryPoints: [],
                mainTypes: [],
                fileCount: 0,
                languages: [],
            },
            error: `No ${PRODUCT_NAME} index found at ${projectPath}. Run ${TOOL_PREFIX}init first.`,
        };
    }

    // Open database
    const db = openDatabase(dbPath, true);
    const queries = createQueries(db);

    try {
        const projectName = db.getMetadata('project_name') ?? basename(projectPath);

        // Read summary.md if exists
        const summaryPath = join(indexDir, 'summary.md');
        let content = '';
        if (existsSync(summaryPath)) {
            content = readFileSync(summaryPath, 'utf-8');
        }

        // Auto-detect entry points
        const entryPoints = detectEntryPoints(queries);

        // Get main types (most referenced)
        const mainTypes = getMainTypes(queries);

        // Get file count
        const stats = db.getStats();

        // Detect languages from file extensions
        const languages = detectLanguages(queries);

        db.close();

        return {
            success: true,
            name: projectName,
            content,
            autoGenerated: {
                entryPoints,
                mainTypes,
                fileCount: stats.files,
                languages,
            },
        };
    } catch (err) {
        db.close();
        return {
            success: false,
            name: '',
            content: '',
            autoGenerated: {
                entryPoints: [],
                mainTypes: [],
                fileCount: 0,
                languages: [],
            },
            error: err instanceof Error ? err.message : String(err),
        };
    }
}

/**
 * Detect entry points based on common patterns
 */
function detectEntryPoints(queries: ReturnType<typeof createQueries>): string[] {
    const files = queries.getAllFiles();
    const entryPatterns = [
        /^(program|main|index|app|application)\.(cs|ts|js|py|rs)$/i,
        /^src\/(program|main|index|app)\.(cs|ts|js|py|rs)$/i,
        /^src\/(main|lib)\.(rs)$/i,
    ];

    const entryPoints: string[] = [];

    for (const file of files) {
        const fileName = file.path.replace(/\\/g, '/');
        for (const pattern of entryPatterns) {
            if (pattern.test(fileName) || pattern.test(basename(fileName))) {
                entryPoints.push(file.path);
                break;
            }
        }
    }

    return entryPoints;
}

/**
 * Get main types (classes/interfaces with most methods)
 */
function getMainTypes(queries: ReturnType<typeof createQueries>): string[] {
    const files = queries.getAllFiles();
    const typeMethodCounts: Array<{ name: string; file: string; methodCount: number }> = [];

    for (const file of files) {
        const types = queries.getTypesByFile(file.id);
        const methods = queries.getMethodsByFile(file.id);

        for (const type of types) {
            // Count methods that likely belong to this type (same file, after type definition)
            const methodCount = methods.filter(m => m.line_number > type.line_number).length;
            typeMethodCounts.push({
                name: type.name,
                file: file.path,
                methodCount,
            });
        }
    }

    // Sort by method count and return top 5
    typeMethodCounts.sort((a, b) => b.methodCount - a.methodCount);
    return typeMethodCounts.slice(0, 5).map(t => `${t.name} (${t.file})`);
}

/**
 * Detect languages from indexed file extensions
 */
function detectLanguages(queries: ReturnType<typeof createQueries>): string[] {
    const files = queries.getAllFiles();
    const extensionMap: Record<string, string> = {
        '.cs': 'C#',
        '.ts': 'TypeScript',
        '.tsx': 'TypeScript',
        '.js': 'JavaScript',
        '.jsx': 'JavaScript',
        '.mjs': 'JavaScript',
        '.cjs': 'JavaScript',
        '.rs': 'Rust',
        '.py': 'Python',
        '.pyw': 'Python',
    };

    const languages = new Set<string>();
    for (const file of files) {
        const ext = file.path.substring(file.path.lastIndexOf('.')).toLowerCase();
        if (extensionMap[ext]) {
            languages.add(extensionMap[ext]);
        }
    }

    return [...languages].sort();
}

// ============================================================
// Tree implementation
// ============================================================

export function tree(params: TreeParams): TreeResult {
    const { path: projectPath, subpath, depth, includeStats } = params;

    // Validate project path
    const indexDir = join(projectPath, INDEX_DIR);
    const dbPath = join(indexDir, 'index.db');

    if (!existsSync(dbPath)) {
        return {
            success: false,
            root: '',
            entries: [],
            totalFiles: 0,
            error: `No ${PRODUCT_NAME} index found at ${projectPath}. Run ${TOOL_PREFIX}init first.`,
        };
    }

    // Open database
    const db = openDatabase(dbPath, true);
    const queries = createQueries(db);

    try {
        const files = queries.getAllFiles();
        const normalizedSubpath = subpath?.replace(/\\/g, '/').replace(/^\/|\/$/g, '') ?? '';

        // Filter files by subpath
        let filteredFiles = files;
        if (normalizedSubpath) {
            filteredFiles = files.filter(f => {
                const normalizedPath = f.path.replace(/\\/g, '/');
                return normalizedPath.startsWith(normalizedSubpath + '/') ||
                       normalizedPath === normalizedSubpath;
            });
        }

        // Build tree structure
        const directories = new Set<string>();
        const entries: TreeEntry[] = [];

        for (const file of filteredFiles) {
            const normalizedPath = file.path.replace(/\\/g, '/');
            const relativePath = normalizedSubpath
                ? normalizedPath.substring(normalizedSubpath.length + 1)
                : normalizedPath;

            // Check depth
            const pathDepth = relativePath.split('/').length;
            if (depth !== undefined && pathDepth > depth) {
                // Just add parent directories up to depth
                const parts = relativePath.split('/');
                for (let i = 0; i < Math.min(depth, parts.length - 1); i++) {
                    const dirPath = parts.slice(0, i + 1).join('/');
                    directories.add(dirPath);
                }
                continue;
            }

            // Add parent directories
            const parts = relativePath.split('/');
            for (let i = 0; i < parts.length - 1; i++) {
                const dirPath = parts.slice(0, i + 1).join('/');
                directories.add(dirPath);
            }

            // Add file entry
            const entry: TreeEntry = {
                path: relativePath,
                type: 'file',
            };

            if (includeStats) {
                const occurrences = queries.getOccurrencesByFile(file.id);
                const methods = queries.getMethodsByFile(file.id);
                const types = queries.getTypesByFile(file.id);

                entry.itemCount = new Set(occurrences.map(o => o.item_id)).size;
                entry.methodCount = methods.length;
                entry.typeCount = types.length;
            }

            entries.push(entry);
        }

        // Add directory entries
        for (const dir of directories) {
            entries.push({
                path: dir,
                type: 'directory',
            });
        }

        // Sort: directories first, then alphabetically
        entries.sort((a, b) => {
            if (a.type !== b.type) {
                return a.type === 'directory' ? -1 : 1;
            }
            return a.path.localeCompare(b.path);
        });

        db.close();

        return {
            success: true,
            root: normalizedSubpath || '.',
            entries,
            totalFiles: filteredFiles.length,
        };
    } catch (err) {
        db.close();
        return {
            success: false,
            root: '',
            entries: [],
            totalFiles: 0,
            error: err instanceof Error ? err.message : String(err),
        };
    }
}

// ============================================================
// Describe - Add content to summary.md
// ============================================================

export interface DescribeParams {
    path: string;
    section: 'purpose' | 'architecture' | 'concepts' | 'patterns' | 'notes';
    content: string;
    replace?: boolean;      // Replace existing section? Default: append
}

export interface DescribeResult {
    success: boolean;
    section: string;
    error?: string;
}

export function describe(params: DescribeParams): DescribeResult {
    const { path: projectPath, section, content, replace = false } = params;

    // Validate project path
    const indexDir = join(projectPath, INDEX_DIR);
    const dbPath = join(indexDir, 'index.db');

    if (!existsSync(dbPath)) {
        return {
            success: false,
            section,
            error: `No ${PRODUCT_NAME} index found at ${projectPath}. Run ${TOOL_PREFIX}init first.`,
        };
    }

    const summaryPath = join(indexDir, 'summary.md');

    try {
        // Read existing summary or create new
        let summaryContent = '';
        if (existsSync(summaryPath)) {
            summaryContent = readFileSync(summaryPath, 'utf-8');
        }

        // Section headers
        const sectionHeaders: Record<string, string> = {
            purpose: '## Purpose',
            architecture: '## Architecture',
            concepts: '## Key Concepts',
            patterns: '## Patterns',
            notes: '## Notes',
        };

        const header = sectionHeaders[section];
        const sectionRegex = new RegExp(`^${header}\\n([\\s\\S]*?)(?=^## |$)`, 'm');

        if (replace) {
            // Replace entire section
            if (sectionRegex.test(summaryContent)) {
                summaryContent = summaryContent.replace(sectionRegex, `${header}\n${content}\n\n`);
            } else {
                // Add new section at end
                summaryContent = summaryContent.trimEnd() + `\n\n${header}\n${content}\n`;
            }
        } else {
            // Append to section
            const match = summaryContent.match(sectionRegex);
            if (match) {
                const existingContent = match[1].trimEnd();
                const newContent = existingContent ? `${existingContent}\n${content}` : content;
                summaryContent = summaryContent.replace(sectionRegex, `${header}\n${newContent}\n\n`);
            } else {
                // Add new section at end
                summaryContent = summaryContent.trimEnd() + `\n\n${header}\n${content}\n`;
            }
        }

        // Write back
        writeFileSync(summaryPath, summaryContent.trimStart());

        return {
            success: true,
            section,
        };
    } catch (err) {
        return {
            success: false,
            section,
            error: err instanceof Error ? err.message : String(err),
        };
    }
}
